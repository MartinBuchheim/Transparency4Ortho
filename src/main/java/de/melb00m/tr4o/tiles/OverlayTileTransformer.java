package de.melb00m.tr4o.tiles;

import de.melb00m.tr4o.app.Transparency4Ortho;
import de.melb00m.tr4o.xptools.XPToolsInterface;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Class that scans a single overlay-DSF file for references to the default roads-library, and
 * changes matching references to the Transparency4Ortho-library generated by the {@link
 * de.melb00m.tr4o.library.LibraryGenerator}.
 *
 * <p>Uses the {@link XPToolsInterface} to transform the DSF-file into a textual representation (and
 * back).
 *
 * @see XPToolsInterface
 * @see de.melb00m.tr4o.library.LibraryGenerator
 * @author Martin Buchheim
 */
public class OverlayTileTransformer implements Runnable {

  private static final Logger LOG = LogManager.getLogger(OverlayTileTransformer.class);
  private static final Set<Pattern> REPLACEMENT_PATTERNS =
      Transparency4Ortho.CONFIG.getStringList("tiletransformer.replacements.patterns").stream()
          .map(Pattern::compile)
          .collect(Collectors.toUnmodifiableSet());

  private final Path dsfFile;
  private final Path backupDsfFile;
  private final String libraryName;
  private final XPToolsInterface xpToolsInterface;

  private boolean transformed;

  /**
   * C'tor
   *
   * @param dsfFile DSF file in which to transform any references to the default road-libraries
   * @param backupFolder Backup folder where a copy of the original DSF is made before applying any
   *     changes
   * @param libraryName Name of the library in the DSF file
   * @param xpToolsInterface Interface to DSFtool
   */
  public OverlayTileTransformer(
      final Path dsfFile,
      final Path backupFolder,
      final String libraryName,
      final XPToolsInterface xpToolsInterface) {
    this.dsfFile = dsfFile;
    this.backupDsfFile =
        backupFolder.resolve(
            dsfFile.getParent().getParent().getParent().getParent().relativize(dsfFile));
    this.libraryName = libraryName;
    this.xpToolsInterface = xpToolsInterface;
  }

  @Override
  public void run() {
    synchronized (this) {
      try {
        LOG.trace("Analyzing overlay tile: {}", dsfFile);
        final var sourceContent = xpToolsInterface.dsfToText(dsfFile);
        final var transformedContent =
            sourceContent
                .lines()
                .map(this::searchAndTransformLine)
                .collect(Collectors.joining(System.lineSeparator()));

        // shortcut: nothing had to be replaced
        if (Objects.equals(sourceContent, transformedContent)) {
          LOG.trace("No modifications in overlay tile necessary: {}", dsfFile);
          return;
        }
        backupOriginalDsfFile();
        LOG.trace("Replacing overlay with transformed version: {}", dsfFile);
        Files.delete(dsfFile);
        xpToolsInterface.textToDsf(dsfFile, transformedContent);
        transformed = true;
      } catch (Exception e) {
        throw new IllegalStateException(
            String.format("Transformation of overlay failed: %s", dsfFile), e);
      }
    }
  }

  private String searchAndTransformLine(final String input) {
    for (Pattern pattern : REPLACEMENT_PATTERNS) {
      var matcher = pattern.matcher(input);
      if (matcher.matches()) {
        return matcher.replaceFirst("${before}" + libraryName + "${after}");
      }
    }
    return input;
  }

  private void backupOriginalDsfFile() throws IOException {
    LOG.trace("Creating backup of original overlay '{} in '{}'", dsfFile, backupDsfFile);
    synchronized (OverlayTileTransformer.class) {
      Files.createDirectories(backupDsfFile.getParent());
    }
    Files.copy(dsfFile, backupDsfFile);
  }

  public boolean isTransformed() {
    return transformed;
  }

  public Path getDsfFile() {
    return dsfFile;
  }

  public Path getBackupDsfFile() {
    return backupDsfFile;
  }
}
